#!/bin/bash

# å…¨å±€é…ç½®
VERSION=1.0-20250810
CONFIG_DIR="/etc/waywrapper"
CONFIG_FILE="$CONFIG_DIR/binaries.conf"

# æ£€æŸ¥æ˜¯å¦ä»¥ root è¿è¡Œï¼ˆå†™ç³»ç»Ÿæ–‡ä»¶éœ€è¦æƒé™ï¼‰
require_sudo_or_root() {
    if [[ $EUID -ne 0 ]]; then
        echo "Error: This script requires root privileges to manage global binaries." >&2
        echo "Please run with sudo." >&2
        exit 1
    fi
}

show_version() {
    echo $VERSION
}

# æ˜¾ç¤ºå¸®åŠ©
show_help() {
    cat << 'EOF'
waywrapper - Wayland wrapper manager for binaries

Usage:
  waywrapper --set-binary-path | -s /path/to/binary
  waywrapper --remove-binary-path | -r /path/to/binary
  waywrapper --update | -u [--dry-run] [--force]
  waywrapper --list | -l
  waywrapper --help | -h
  waywrapper --version | -v

Options:
  --set-binary-path, -s      Register a binary for Wayland wrapping
  --remove-binary-path, -r   Unregister a binary
  --update, -u               Apply wrapper scripts to registered binaries
  --update --dry-run         Simulate update (no changes made)
  --update --force           Re-wrap even if already wrapped
  --list, -l                 List all registered binaries
  --help, -h                 Show this help message
  --version, -v              Show version
EOF
}

# æ£€æŸ¥æ˜¯å¦æ˜¯ wrapper è„šæœ¬
is_wrapper_script() {
    local file="$1"
    [[ -f "$file" ]] || return 1
    head -n 5 "$file" 2>/dev/null | grep -q "IsWrapper=true"
}

# æ³¨å†ŒäºŒè¿›åˆ¶
set_binary_path() {
    local path="$1"
    if [[ ! -f "$path" ]]; then
        echo "Error: Binary not found: $path" >&2
        exit 1
    fi

    mkdir -p "$CONFIG_DIR"
    touch "$CONFIG_FILE"

    if grep -Fxq "$path" "$CONFIG_FILE" 2>/dev/null; then
        echo "Already registered: $path"
    else
        echo "$path" >> "$CONFIG_FILE"
        echo "Registered: $path"
    fi
}

# ç§»é™¤å·²æ³¨å†Œçš„äºŒè¿›åˆ¶
remove_binary_path() {
    local path="$1"
    if grep -Fxq "$path" "$CONFIG_FILE" 2>/dev/null; then
        sed -i "\|$path|d" "$CONFIG_FILE"
        echo "Removed from registry: $path"
    else
        echo "Not found in registry: $path"
    fi
}

# åˆ—å‡ºæ‰€æœ‰æ³¨å†Œçš„äºŒè¿›åˆ¶
list_binaries() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo "No binaries registered."
        return 0
    fi

    echo "Registered binaries:"
    grep -v '^$' "$CONFIG_FILE" | while IFS= read -r bin; do
        if [[ -n "$bin" ]]; then
            local status="not exists"
            if [[ -f "$bin" ]]; then
                if is_wrapper_script "$bin"; then
                    status="wrapped"
                else
                    status="raw binary (not wrapped)"
                fi
            elif [[ -f "$bin.orig" ]]; then
                status="original exists (.orig)"
            fi
            printf "  %s (%s)\n" "$bin" "$status"
        fi
    done
}

is_vscode_binary() {
    local path="$1"
    # å¯æ‰©å±•ä¸ºæ•°ç»„æ”¯æŒå¤šä¸ªè·¯å¾„
    [[ "$path" == "/usr/share/code/code" ]] || \
    [[ "$path" == "/usr/bin/code" ]] || \
    [[ "$path" == "/opt/visual-studio-code/code" ]]
}

create_wrapper_script() {
    local wrapper_path="$1"
    local orig_path="$2"
    local pass_args="${3:-true}"  # æ–°å¢ï¼šæ˜¯å¦ä¼ é€’ "$@"

    cat > "$wrapper_path" << 'EOF'
#!/bin/bash
# waywrapper: Wrapper script to enable Wayland via Ozone
IsWrapper=true

# Resolve the absolute path of the original binary
ORIG_BINARY="$(readlink -f "$0").orig"

# Safety check: ensure .orig file exists
if [[ ! -f "$ORIG_BINARY" ]]; then
    echo "âŒ waywrapper: Critical error - original binary missing:" >&2
    echo "    $ORIG_BINARY" >&2
    echo "ğŸ’¡ Run 'sudo waywrapper --update' to fix, or restore manually." >&2
    exit 1
fi

# Enable Wayland by default
EOF

    # åŠ¨æ€æ·»åŠ æ‰§è¡Œå‘½ä»¤ï¼ˆæ˜¯å¦å¸¦ "$@"ï¼‰
    if [[ "$pass_args" == "true" ]]; then
        cat >> "$wrapper_path" << 'EOF'
exec "$ORIG_BINARY" --ozone-platform-hint=wayland --enable-wayland-ime "$@"
EOF
    else
        cat >> "$wrapper_path" << 'EOF'
exec "$ORIG_BINARY" --ozone-platform-hint=wayland --enable-wayland-ime
EOF
    fi

    # æ¢å¤æƒé™
    if [[ -f "$orig_path" ]]; then
        chmod --reference="$orig_path" "$wrapper_path" 2>/dev/null || chmod +x "$wrapper_path"
    else
        chmod +x "$wrapper_path"
    fi
}

update_binaries() {
    local dry_run=false
    local force=false

    # è§£æé€‰é¡¹
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                dry_run=true
                shift
                ;;
            --force)
                force=true
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo "No binaries registered. Use --set-binary-path first."
        return 0
    fi

    local total=0
    local skipped=0
    local processed=0
    local repaired=0

    while IFS= read -r binary_path; do
        [[ -z "$binary_path" ]] && continue
        ((total++))

        if [[ ! -f "$binary_path" ]]; then
            echo "âš ï¸  Binary not found: $binary_path"
            continue
        fi

        local orig_path="$binary_path.orig"

        # åˆ¤æ–­æ˜¯å¦å·²ç»æ˜¯ wrapper è„šæœ¬
        if is_wrapper_script "$binary_path"; then
            if [[ "$force" != true ]] && [[ "$dry_run" != true ]]; then
                echo "â­ï¸  Skipping (already wrapped): $binary_path"
                ((skipped++))
                continue
            fi

            if [[ "$dry_run" == true ]]; then
                echo "ğŸ“ Would re-wrap (update wrapper): $binary_path"
                ((processed++))
                continue
            fi

            # å¼ºåˆ¶æ›´æ–°ï¼šæ£€æŸ¥ .orig æ˜¯å¦å­˜åœ¨
            if [[ ! -f "$orig_path" ]]; then
                echo "âŒ Wrapper exists but original backup missing: $orig_path"
                echo "ğŸ’¡ Cannot restore. Skipping: $binary_path"
                continue
            fi

            rm -f "$binary_path"
            echo "ğŸ”§ Removed old wrapper: $binary_path"

            # åˆ¤æ–­æ˜¯å¦ä¸º VSCode æ¨¡å¼ï¼ˆä¸ä¼ é€’ "$@"ï¼‰
            local pass_args="true"
            if is_vscode_binary "$binary_path"; then
                pass_args="false"
                echo "ğŸ”§ VSCode mode: wrapper will NOT pass \$@"
            fi

            create_wrapper_script "$binary_path" "$orig_path" "$pass_args"
            echo "âœ¨ Updated wrapper: $binary_path"
            ((repaired++))
            continue
        fi

        # ==================================================================
        # âœ… æƒ…å†µï¼šå½“å‰ binary ä¸æ˜¯ wrapper è„šæœ¬ï¼ˆå¯èƒ½æ˜¯æ–°å®‰è£…æˆ–åŒ…ç®¡ç†å™¨æ›´æ–°åï¼‰
        # ==================================================================

        if [[ "$dry_run" == true ]]; then
            local mode="new"
            if is_vscode_binary "$binary_path"; then
                mode="new (VSCode mode, no \$@)"
            fi
            echo "ğŸ“ Would wrap ($mode): $binary_path"
            ((processed++))
            continue
        fi

        # æ£€æŸ¥æ˜¯å¦ä¸ºå¯æ‰§è¡Œæ–‡ä»¶ï¼ˆé˜²æ­¢è¯¯æ“ä½œè„šæœ¬æˆ–é“¾æ¥ï¼‰
        if ! file "$binary_path" | grep -qE "executable|ELF"; then
            echo "âš ï¸  Not a binary executable: $binary_path"
            echo "    Skipping. If this is intentional, use a wrapper manually."
            ((skipped++))
            continue
        fi

        # å¦‚æœ .orig å­˜åœ¨ï¼Œè¯´æ˜ä¹‹å‰åŒ…è£…è¿‡ï¼Œä½†ç°åœ¨ binary è¢«æ›¿æ¢äº†ï¼ˆå¦‚ apt upgradeï¼‰
        if [[ -f "$orig_path" ]]; then
            echo "ğŸ”„ Detected package update: original wrapper lost, new binary in place."
            echo "    Backing up CURRENT $binary_path to $orig_path (overwriting old .orig)"

            # å°†å½“å‰æ–°äºŒè¿›åˆ¶è¦†ç›–åˆ° .origï¼ˆä¿ç•™æœ€æ–°ç‰ˆæœ¬ï¼‰
            if mv -f "$binary_path" "$orig_path"; then
                echo "ğŸ“¦ Updated backup: $orig_path"
            else
                echo "âŒ Failed to update .orig backup: $binary_path â†’ $orig_path" >&2
                continue
            fi
        else
            # æ­£å¸¸é¦–æ¬¡åŒ…è£…ï¼šé‡å‘½ååŸ binary ä¸º .orig
            if mv "$binary_path" "$orig_path"; then
                echo "ğŸ“¦ First-time wrap: $binary_path -> $orig_path"
            else
                echo "âŒ Failed to rename $binary_path to $orig_path" >&2
                continue
            fi
        fi

        # å†³å®šæ˜¯å¦ä¼ é€’ "$@"
        local pass_args="true"
        if is_vscode_binary "$binary_path"; then
            pass_args="false"
            echo "ğŸ”§ Applying VSCode mode: wrapper will NOT pass \$@"
        fi

        # åˆ›å»ºæ–°çš„ wrapper è„šæœ¬
        create_wrapper_script "$binary_path" "$orig_path" "$pass_args"
        echo "âœ¨ Created wrapper: $binary_path"
        ((processed++))

    done < "$CONFIG_FILE"

    # è¾“å‡ºç»Ÿè®¡
    echo "---"
    echo "Summary: $total total"
    echo "         $processed new wrapped, $repaired updated, $skipped skipped"
    if [[ "$dry_run" == true ]]; then
        echo "(Dry run mode: no changes were made)"
    fi
}

# ä¸»å‡½æ•°
main() {
    # è‡³å°‘ä¸€ä¸ªå‚æ•°
    [[ $# -eq 0 ]] && show_help && exit 1

    case "$1" in
        --version|-v)
            show_version
            ;;
        --set-binary-path|-s)
            require_sudo_or_root
            if [[ -z "$2" ]]; then
                echo "Error: Missing path for --set-binary-path" >&2
                exit 1
            fi
            set_binary_path "$2"
            ;;

        --remove-binary-path|-r)
            require_sudo_or_root
            if [[ -z "$2" ]]; then
                echo "Error: Missing path for --remove-binary-path" >&2
                exit 1
            fi
            remove_binary_path "$2"
            ;;

        --list|-l)
            if [[ -f "$CONFIG_FILE" ]]; then
                list_binaries
            else
                echo "No binaries registered."
            fi
            ;;

        --update|-u)
            require_sudo_or_root
            shift
            update_binaries "$@"
            ;;

        --help|-h)
            show_help
            ;;

        *)
            echo "Unknown option: $1" >&2
            echo "Use --help for usage." >&2
            exit 1
            ;;
    esac
}

# æ‰§è¡Œ
main "$@"
